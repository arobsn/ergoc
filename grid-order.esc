{
  // [ Registers ]
  //   R4: SigmaProp        - Owner script
  //   R5: Coll[Long]       - [buy, sell] target prices
  //   R6: Coll[Long]       - [base limit, target limit], the maximum amount of the asset units to be traded
  //                          - If it's set to zero, the order will be auto compounded, which means that all 
  //                            the amounts contained in the box can be traded
  //                          - If it's is greater than zero, the order will accumulate the corresponding 
  //                            asset by limiting the amount of the corresponding asset that can be traded
  //   R7: Coll[Byte]       - Recreated output ID

  // [ Context variables ]
  //   0: Boolean           - Action, true == buy, false = sell
  //   1: Int               - Recreated output index

  // [ Constants ]
  //   $tokenId: Coll[Byte]   - The TokenID of the target asset

  // [ Expected actions ]
  //   - Buy
  //   - Sell
  //   - Withdrawal

  val tokenId: Coll[Byte] = fromBase64("3q2+7w=="); // 'deadbeef', tokenId placeholder
  val recreatedOutputIndex = getVar[Int](0);
  val trading = recreatedOutputIndex.isDefined;

  if (trading) { // perform a trade
    val buying = getVar[Boolean](0).get;  // true == buy, false == sell
    val prices = SELF.R5[Coll[Long]].get; // [buy, sell] prices
    val limits = SELF.R6[Coll[Long]].get; // [base, target] max tradeable limits
    val recreatedOutputId = SELF.R9[Coll[Byte]].get;
    val token = SELF.tokens(0);

    if (buying) {
      val i = 0;
      val price = prices(i); // buy price
      val limit = if (limits(i) > 0L) { limits(i) } else { SELF.value }; // base limit

      sigmaProp(limit > price)
    } else {
      val i = 1;  
      val price = prices(i); // sell price
      val limit = if (limits(i) > 0L) { limits(i) } else { token._2 }; // target limit
   
      sigmaProp(price > limit)
    }
  } else { // withdrawal funds
    SELF.R4[SigmaProp].get // owner script
  }
}
